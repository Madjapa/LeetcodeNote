给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。

提示：



0 <= n <= 10^5



:::info
第一想法：

O（n^2时间复杂度），空间O（n）

第一个循环遍历0-n,

内部第二个循环遍历i的二进制，找出1的个数并保存；



认为第一想法效率太低了，不想写，思考另一个想法



第二想法：

动态规划：由于思考后发现 011 与110之间是两倍的关系，也就是说f（n） = f(log2n)，也就是说除质数外的都可以沿用以前的记录。

:::

结果：

![](https://cdn.nlark.com/yuque/0/2024/png/25562551/1727857327096-e89f98d5-6093-4418-9bc8-6fe97b303620.png)

![](https://cdn.nlark.com/yuque/0/2024/png/25562551/1727857299943-2b20b53c-4ba1-4344-a820-bba231228c98.png)

进阶：

![](https://cdn.nlark.com/yuque/0/2024/png/25562551/1727857391286-be43f6bf-4621-4ae3-b917-b064a2fbb1cf.png)

1.O（n）真的可行吗，思考7min左右想不出来，看看答案算了：



对于所有的数字，只有两类：



奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。

          举例： 

         0 = 0       1 = 1

         2 = 10      3 = 11

偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。

           举例：

          2 = 10       4 = 100       8 = 1000

          3 = 11       6 = 110       12 = 1100

另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。



2.不使用内置函数的话就如下：

```cpp
int count = 0,testnum = i;
while(testnum > 0){
    count += testnum & 1;
    testnum >>= 1; 
}
这个时间复杂度是O（n）
```

时间复杂度为O（logn）的是二分，但还没时间了解详细，等做完简单题分析后再单独出个位运算专栏笔记。




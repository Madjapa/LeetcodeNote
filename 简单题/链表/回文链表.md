给你一个单链表的头节点 head ，请你判断该链表是否为

回文链表

。如果是，返回 true ；否则，返回 false 。



:::info
第一想法：建造另一个链表，该链表是原链表的逆序，然后同时扫描两个链表，若完全相同则是回文链表。扫描次数3次，时间O（n）,空间O（n）

:::

:::info
第二想法：扫描一遍链表建立一个数组，数组头尾往中间扫描直至相遇或超过，若过程无不同则链表是回文

:::

最终采用第一想法，结果并不是很好

![](https://cdn.nlark.com/yuque/0/2024/png/25562551/1727794328322-6610eec8-ed60-4767-b20a-271dde609048.png)

采用第二想法：

![](https://cdn.nlark.com/yuque/0/2024/png/25562551/1727794605859-7663178d-632b-49b1-b3bc-e522877716ff.png)

看看答案：

答案方法一就是第二想法；

方法二：递归，开销很大；

方法三：将后半段逆序，然后两个指针（一个从开头一个从中间）开始遍历（比方法一空间要求更少。O（1））



10.3更新：

复习时想到的另解：

前面一半用栈存起来，到中间时（奇数个时不存中间的数进栈，也不比较）与栈进行比较，若有不同则非回文。



